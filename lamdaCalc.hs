{- lamdaCalc.hs

Turing Machine computations are easy to implement on electronic devices, 
this happened during the Second World War. 

universality was employed by von Neumann (a collegue of Turing's) to construct ad hoc computers and a universal one. 
The universal one was capable of performing different tasks depending on a program. 
This resulted in what is now called imperative programming, with the C language presently the most widely used for programming in this paradigm. 
As with Turing Machines a computation consists of repeated modifications of some data stored in memory. 
Difference between our computers and a Turing Machine is that the our computers have random access memory. 


‘referential transparency’ All expressions of a functional programming language have a constant meaning (i.e. independent of a hidden state).

Functions may be arguments of other functions, usually called ‘functionals’ in mathematics and higher-order functions in programming.
thier use enables the flexible composition of algorithms.

Algorithms can be expressed in a goal-directed mathematical way, 
using various forms of recursion and flexible data structures. 
The storage bookkeeping of these values is handled by the compiler, leaving the user to concentrate on other things. 
To not do this is to bet against the house. 

The formalism as defined by Church is untyped. The early functional languages, of which Lisp (McCarthy et al. (1962)) and Scheme (Abelson et al. (1991)) are best known, are also untyped: ARBITRARY EXPRESSIONS MAY BE APPLIED TO EACH OTHER!!!!
Types first appeared in Principia Mathematica, Whitehead and Russell (1910-1913). In Curry (1934) types are introduced and assigned to expressions in ‘combinatory logic’, a formalism closely related to lambda calculus. In Curry and Feys (1958) this type assignment mechanism was adapted to λ-terms, while in Church (1940) λ-terms were ornamented by fixed types. "λCu ->" and "λCh ->"
Types act in a way similar to the use of dimensional analysis in physics.
 
