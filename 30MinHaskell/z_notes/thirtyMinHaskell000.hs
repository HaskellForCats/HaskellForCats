module ThrtyMn000 where 
-- : retab 
-- single line comments 
{- multi-line comments -} 
{- 
Who am I? 
I have done Slam Poetry, LiveTV, music composition, and journalism.  

        Basic -> in high school, my unremarkable intro to programming. 
        Pascal -> in College left me with a profound sense of pointlessness. 
        C/C++ -> same as above
        tech support & system administration 
            a better understanding of tech systems and people using it.
        Java for Android -> programming as intro to pain driven development. 
        GO -> exciting but not ready for prime-time;(that has since changed.)
        Lisp -> Exuberance at what was possible soon to be dashed by the scarcity of it's implementation.
        JavaScript -> Loved it at first. Easiest install ever; now I fear it like the plague. 
        Php -> a necessary evil because it's useful and quick //  but a hot-mess
        Ruby -> good enough, maybe a lisp with objects.  
        Rails -> too magical, too forgiving of my dyslexic mistakes.
        Clojure -> True love at first sight, but came with a pet dinosaur (the JVM)  
        Haskell -> Marriage Material, not only programming but math and logic as well. 
        Objective-C -> a Faustian bargain for lots of typing and $$$$$.  
        Swift -> Great but not ready for prime time just yet.
        F# -> about as close to Haskell I was gonna get and get paid for it.
        Prolog -> good that I hadn't experienced it before Haskell as I might have succumbed to it's siren song.
        C# -> another Faustian bargain I made for $$$$$.
 
Spent about 3+ years proving to my self, Paul Graham's observation all programming is some derivation of  of C occasionally informed by Lisp.
Haskell is my Lisp, C# is my C, presently. 
I consider Clojure as my first love, 
but Haskell turned out to be marriage material. 



What is it? 
http://www.haskell.org/haskellwiki/Haskell
  Pure 
    no "real world" compromises
      thus more consistent 
      few W.T.F.s  

  Purely Functional 
    functions are the primary means of getting work done 
    functions can be passed as values. 
    functions are values.
  functions can be partially evaluated.
    functions are easier to reason about than are objects
        see smalltalk example: thirtyMinHaskell000a.hs 
    2+3=5
    2+3=5 Â± 1  

  Immutable like mathematics
    for the life of the runtime (until you the programmer change it)  
    no swappable shared memory
        because shared swappable memory is the devil 
      no four horsemen of the parallel apocalypse 
              race conditions 
              priority inversions
              Live Locks 
              Deadlocks
       changes are pointers to new values
        this sounds expensive but it's not
        this sounds restrictive but it's not

  Lazy (opposite of eager)
    nothing gets computed until it is called
      and only so much as is needed to be called
        save on resources 
    can tackle infinite data sets 

  Statically typed ("strongly" "not weakly") 
    no casting to mutate types
    no wrapping to obscure types
    by stronger we mean stronger than: 
      C or C# or Java or C++ (weak static) 
          allows for some coercion of types.

  Parallelization 
    turns out that 
    purity, 
    laziness, 
    immutability, 
    static typing, 
    make Parallelization easier
    
  Concision about as much code as Ruby but 25x faster. 
 
    Haskell "feels" dynamic most of the time   
      because of type inference thanks to the Hindley-Milner type system.


 

-- Haskell lets you play with sharp objects and not cut yourself. 
Video --  knife game.
https://www.youtube.com/watch?v=DzjMKM9449M

The ass you save may be your own.

-}    





